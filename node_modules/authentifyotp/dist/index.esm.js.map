{"version":3,"file":"index.esm.js","sources":["../lib/utils.js","../lib/base32.js","../lib/otp.js"],"sourcesContent":["/**\r\n #PLAN\r\n 1 - generateSecret: creates cryptographically secure secret buffers.\r\n 2 - assertSecretStrong: ensures minimum secret length.\r\n 3 - intToBuffer: convert counter to 8-byte buffer.\r\n 4 - timingSafeCompare: wrapper around crypto.timingSafeEqual with safe padding.\r\n */\r\n\r\nimport crypto from 'crypto'\r\n\r\n/**\r\n * Generate a cryptographically secure random secret buffer.\r\n * Default 32 bytes (256 bits) which is considered secure for OTP secrets.\r\n * @param {number} bytes -number of bytes to generate (default 32)\r\n * @return {Buffer}\r\n */\r\n\r\n//generateSecret: creates cryptographically secure secret buffers.\r\nfunction generateSecret(bytes = 32) {\r\n    return crypto.randomBytes(bytes)\r\n}\r\n\r\n\r\n/**\r\n * Ensure the secret buffer has at least the required minimum bytes.\r\n * Throws an error if too short.\r\n *\r\n * @param {Buffer} buf\r\n * @param {number} minBytes\r\n */\r\n\r\n//assertSecretStrong: ensures minimum secret length.\r\nfunction assertSecretStrong(buf, minBytes = 32) {\r\n    if (!Buffer.isBuffer(buf)) {\r\n        throw new Error(\"Secret must be provided as a Buffer or base32 string decoded to Buffer.\")\r\n    }\r\n    if (buf.length < minBytes) {\r\n        throw new Error(`Secret must be at least ${minBytes} bytes (${minBytes * 8}).`)\r\n    }\r\n}\r\n\r\n/**\r\n * Convert a number or bigint into an 8-byte big-endian Buffer.\r\n * Required by the HOTP algorithm.\r\n *\r\n * @param {number|bigint} num\r\n * @returns {Buffer}\r\n */\r\n\r\n//intToBuffer: convert counter to 8-byte buffer.\r\nfunction intToBuffer(num){\r\n    const buf = Buffer.alloc(8);\r\n    let value = BigInt(num);\r\n    for(let i = 7; i >=0; i--){\r\n        buf[i] = Number(value & 0xffn);\r\n        value >>= 8n;\r\n    }\r\n    return buf;\r\n}\r\n\r\n/**\r\n * Timing-safe compare two Buffers. If lengths differ, pads to same length to avoid\r\n * leaking information via timing.\r\n *\r\n * @param {Buffer} a\r\n * @param {Buffer} b\r\n * @returns {boolean}\r\n */\r\n\r\n//timingSafeCompare: wrapper around crypto.timingSafeEqual with safe padding.\r\nfunction timingSafeCompare(bufA, bufB){\r\n    if(!Buffer.isBuffer(bufA)) bufA = Buffer.from(String(bufA));\r\n    if(!Buffer.isBuffer(bufB)) bufB = Buffer.from(String(bufB));\r\n    if(bufA.length === bufB.length) {\r\n        return crypto.timingSafeEqual(bufA, bufB);\r\n    }\r\n\r\n    const maxLength = Math.max(bufA.length, bufB.length);\r\n    const aa = Buffer.alloc(maxLength);\r\n    const bb = Buffer.alloc(maxLength);\r\n    bufA.copy(aa, maxLength - bufA.length);\r\n    bufB.copy(bb, maxLength - bufB.length);\r\n    return crypto.timingSafeEqual(aa, bb);\r\n}\r\n\r\nexport { generateSecret, assertSecretStrong, intToBuffer, timingSafeCompare }","//Base32 encoder / decoder compatible with RFC 4648 without padding.\r\n//Used to represent secrets in a human-friendly form\r\n//we intentionally implement a small, dependency-free base32 utility so there\r\n//is no external dependency.\r\n\r\nconst ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\r\n\r\n/**\r\n * Convert a Base32 string into a Buffer.\r\n * Accepts input with or without padding and ignores whitespace and hyphens.\r\n *\r\n * @param {string} base32 - base32 encoded string\r\n * @returns {Buffer} decoded binary\r\n */\r\n\r\nfunction base32ToBuffer(base32){\r\n    //Normalize and clean input\r\n    base32 = String(base32).replace(/=+$/g, '').toUpperCase().replace(/[\\s-]/g, '')\r\n    let bits = 0;\r\n    let value = 0;\r\n    const bytes = [];\r\n\r\n    for(const char of base32){\r\n        const index = ALPHABET.indexOf(char);\r\n        if(index === -1){\r\n            throw new Error(`Invalid base32 character: ${char}`);\r\n        }\r\n        value = (value << 5) | index;\r\n        bits += 5;\r\n        if(bits >= 8) {\r\n            bits -= 8;\r\n            bytes.push((value >>> bits) & 0xff);\r\n        }\r\n    }\r\n\r\n    return Buffer.from(bytes);\r\n}\r\n\r\n/**\r\n * convert a Buffer into Base32 string (no padding)\r\n * \r\n * @param {Buffer} buf -binary buffer\r\n * @returns {string} base32 string\r\n */\r\n\r\nfunction bufferToBase32(buf){\r\n    let bits = 0;\r\n    let value = 0;\r\n    let output = '';\r\n\r\n    for(const byte of buf){\r\n        value = (value << 8) | byte;\r\n        bits += 8;\r\n        while(bits >= 5){\r\n            bits -= 5;\r\n            output += ALPHABET[(value >>> bits) & 31]\r\n        }\r\n    }\r\n    if(bits > 0) {\r\n        output += ALPHABET[(value << (5 - bits)) & 31]\r\n    }\r\n    return output;\r\n}\r\n\r\n export { base32ToBuffer, bufferToBase32 }","// Core OTP (one-time password) implementation.\r\n// Supports HOTP (counter-based) and TOTP (time-based).\r\n\r\n// Security decisions:\r\n// - Default HMAC algorithm is sha256 (stronger than sha1).\r\n// - Minimum secret length is 32 bytes (256 bits).\r\n// - All comparisons use timing-safe routines.\r\n\r\nimport crypto from 'crypto'\r\nimport { base32ToBuffer } from './base32.js';\r\nimport { assertSecretStrong, intToBuffer, timingSafeCompare } from './utils.js';\r\n\r\n\r\n\r\n\r\n//Default security constants\r\nconst DEFAULT_DIGITS = 6; //number of digits in OTP\r\nconst DEFAULT_ALGORITHM = 'sha256'; //default HMAC algorithm\r\nconst DEFAULT_STEP = 30; // 30-second step for TOTP\r\nconst MIN_SECRET_BYTES = 32; // 32 BYTES = 256 BITS\r\n\r\n/**\r\n #PLAN \r\n 1 - Normalize secret input to Buffer.\r\n 2 - Accepts either a Buffer or a base32 string\r\n\r\n  @param {Buffer|string} secret\r\n  @returns {Buffer}\r\n */\r\n\r\n//Normalize secret input to Buffer.\r\nfunction normalizeSecret(secret) {\r\n    if (Buffer.isBuffer(secret)) return secret;\r\n    if (typeof secret === 'string') return base32ToBuffer(secret);\r\n    throw new Error('Secret must be a Buffer or base32 encoded string.');\r\n}\r\n\r\n\r\n/**\r\n * Generate an H O T P code string\r\n * @param {Buffer|string} secret - Buffer or base32 string\r\n * @param {number|bigint} counter - moving counter\r\n * @param {object} opts - { digits, algorithm }\r\n * @returns {string} zero-padded numeric code\r\n */\r\n\r\nfunction hotp(secret, counter, opts = {}) {\r\n    const digits = opts.digits || DEFAULT_DIGITS;\r\n    const algorithm = opts.algorithm || DEFAULT_ALGORITHM;\r\n\r\n    const key = normalizeSecret(secret);\r\n\r\n    assertSecretStrong(key, MIN_SECRET_BYTES);\r\n\r\n    const counterBuf = intToBuffer(counter);\r\n\r\n    const hmac = crypto.createHmac(algorithm, key).update(counterBuf).digest();\r\n\r\n    const offset = hmac[hmac.length - 1] & 0x0f; //dynamic truncation offset\r\n    const codeInt = (hmac.readUInt32BE(offset) & 0x7fffffff) % 10 ** digits;\r\n\r\n    return String(codeInt).padStart(digits, '0');\r\n}\r\n\r\n\r\n/**\r\n * Verify an HOTP code against a counter and optional look-ahead window.\r\n * Returns { ok: boolean, usedCounter?: bigint }.\r\n *\r\n * Note for implementers: store the usedCounter in your user storage to\r\n * prevent replay; only accept counters strictly greater than stored value.\r\n */\r\n\r\nfunction hotpVerify(token, secret, counter, lookAhead = 0, opts = {}) {\r\n    const digits = opts.digits || DEFAULT_DIGITS;\r\n    const paddedToken = String(token).padStart(digits, '0');\r\n    for (let i = 0; i <= lookAhead; i++) {\r\n        const c = BigInt(counter) + BigInt(i);\r\n        const expected = hotp(secret, c, opts);\r\n        if(timingSafeCompare(Buffer.from(expected), Buffer.from(paddedToken))){\r\n            return { ok: true, usedCounter: c }\r\n        }\r\n    }\r\n    return { ok: false };\r\n}\r\n\r\n\r\n/**\r\n * Generate a T O T P code for the current time.\r\n *\r\n * @param {Buffer|string} secret\r\n * @param {object} opts - { step, digits, algorithm }\r\n * @returns {string}\r\n */\r\n\r\nfunction totp(secret, opts ={}){\r\n    const step = opts.step || DEFAULT_STEP;\r\n    const counter = Math.floor(Date.now() / 1000 / step);\r\n    return hotp(secret, counter, opts)\r\n}\r\n\r\n\r\n/**\r\n * Verify a T O T P token. Allows a window of steps before/after current step.\r\n * Returns { ok: boolean, delta?: number } where delta is the step offset.\r\n *\r\n * Implementers: for replay protection store the last accepted step value.\r\n */\r\n\r\nfunction totpVerify(token, secret, opts={}){\r\n    const step = opts.step || DEFAULT_STEP;\r\n    const window = typeof opts.window === 'number' ? opts.window : 1; //allow Â±1 by default \r\n    const digits = opts.digits || DEFAULT_DIGITS;\r\n\r\n    //current time step counter\r\n    const nowCounter = Math.floor(Date.now() / 1000 / step);\r\n\r\n    for(let i = -window; i < window; i++){\r\n        const counter = BigInt(nowCounter + i);\r\n        const expected = hotp(secret, counter, opts);\r\n        if(timingSafeCompare(Buffer.from(expected), Buffer.from(String(token).padStart(digits, '0')))){\r\n            return { ok: true, delta: 1 }\r\n        }\r\n    }\r\n    return { ok: false }\r\n}\r\n\r\n/**\r\n * Convenience helper: create an \"otpauth\" URI string that can be turned into\r\n * a QR code for Google Authenticator, Authy, etc.\r\n *\r\n * Format example:\r\n * otpauth://totp/Issuer:account@example.com?secret=BASE32SECRET&issuer=Issuer&algorithm=SHA256&digits=6&period=30\r\n *\r\n * @param {object} params - { secretBase32, label, issuer, algorithm, digits, period }\r\n * @returns {string}\r\n */\r\n\r\nfunction generateOtpauthURI(params ={}){\r\n    if(!params.secretBase32) throw new Error('secretBase32 required');\r\n    const label = encodeURIComponent(params.label || 'user');\r\n    const issuer = encodeURIComponent(params.issuer || 'authentify');\r\n    const algorithm = (params.algorithm || DEFAULT_ALGORITHM).toUpperCase();\r\n    const digits = params.digits || DEFAULT_DIGITS;\r\n    const period = params.period || DEFAULT_STEP;\r\n\r\n    return `otpauth://totp/${issuer}:${label}?secret=${params.secretBase32}&issuer=${issuer}&algorithm=${algorithm}&digits=${digits}&period=${period}`;\r\n}\r\n\r\nexport{\r\n    hotp,\r\n    hotpVerify,\r\n    totp,\r\n    totpVerify,\r\n    generateOtpauthURI,\r\n    DEFAULT_DIGITS,\r\n    DEFAULT_ALGORITHM,\r\n    DEFAULT_STEP,\r\n    MIN_SECRET_BYTES\r\n};\r\n\r\n"],"names":[],"mappings":"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"}