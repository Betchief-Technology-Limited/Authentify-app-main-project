'use strict';

var crypto = require('crypto');

/**
 #PLAN
 1 - generateSecret: creates cryptographically secure secret buffers.
 2 - assertSecretStrong: ensures minimum secret length.
 3 - intToBuffer: convert counter to 8-byte buffer.
 4 - timingSafeCompare: wrapper around crypto.timingSafeEqual with safe padding.
 */


/**
 * Generate a cryptographically secure random secret buffer.
 * Default 32 bytes (256 bits) which is considered secure for OTP secrets.
 * @param {number} bytes -number of bytes to generate (default 32)
 * @return {Buffer}
 */

//generateSecret: creates cryptographically secure secret buffers.
function generateSecret(bytes = 32) {
    return crypto.randomBytes(bytes)
}


/**
 * Ensure the secret buffer has at least the required minimum bytes.
 * Throws an error if too short.
 *
 * @param {Buffer} buf
 * @param {number} minBytes
 */

//assertSecretStrong: ensures minimum secret length.
function assertSecretStrong(buf, minBytes = 32) {
    if (!Buffer.isBuffer(buf)) {
        throw new Error("Secret must be provided as a Buffer or base32 string decoded to Buffer.")
    }
    if (buf.length < minBytes) {
        throw new Error(`Secret must be at least ${minBytes} bytes (${minBytes * 8}).`)
    }
}

/**
 * Convert a number or bigint into an 8-byte big-endian Buffer.
 * Required by the HOTP algorithm.
 *
 * @param {number|bigint} num
 * @returns {Buffer}
 */

//intToBuffer: convert counter to 8-byte buffer.
function intToBuffer(num){
    const buf = Buffer.alloc(8);
    let value = BigInt(num);
    for(let i = 7; i >=0; i--){
        buf[i] = Number(value & 0xffn);
        value >>= 8n;
    }
    return buf;
}

/**
 * Timing-safe compare two Buffers. If lengths differ, pads to same length to avoid
 * leaking information via timing.
 *
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {boolean}
 */

//timingSafeCompare: wrapper around crypto.timingSafeEqual with safe padding.
function timingSafeCompare(bufA, bufB){
    if(!Buffer.isBuffer(bufA)) bufA = Buffer.from(String(bufA));
    if(!Buffer.isBuffer(bufB)) bufB = Buffer.from(String(bufB));
    if(bufA.length === bufB.length) {
        return crypto.timingSafeEqual(bufA, bufB);
    }

    const maxLength = Math.max(bufA.length, bufB.length);
    const aa = Buffer.alloc(maxLength);
    const bb = Buffer.alloc(maxLength);
    bufA.copy(aa, maxLength - bufA.length);
    bufB.copy(bb, maxLength - bufB.length);
    return crypto.timingSafeEqual(aa, bb);
}

//Base32 encoder / decoder compatible with RFC 4648 without padding.
//Used to represent secrets in a human-friendly form
//we intentionally implement a small, dependency-free base32 utility so there
//is no external dependency.

const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

/**
 * Convert a Base32 string into a Buffer.
 * Accepts input with or without padding and ignores whitespace and hyphens.
 *
 * @param {string} base32 - base32 encoded string
 * @returns {Buffer} decoded binary
 */

function base32ToBuffer(base32){
    //Normalize and clean input
    base32 = String(base32).replace(/=+$/g, '').toUpperCase().replace(/[\s-]/g, '');
    let bits = 0;
    let value = 0;
    const bytes = [];

    for(const char of base32){
        const index = ALPHABET.indexOf(char);
        if(index === -1){
            throw new Error(`Invalid base32 character: ${char}`);
        }
        value = (value << 5) | index;
        bits += 5;
        if(bits >= 8) {
            bits -= 8;
            bytes.push((value >>> bits) & 0xff);
        }
    }

    return Buffer.from(bytes);
}

/**
 * convert a Buffer into Base32 string (no padding)
 * 
 * @param {Buffer} buf -binary buffer
 * @returns {string} base32 string
 */

function bufferToBase32(buf){
    let bits = 0;
    let value = 0;
    let output = '';

    for(const byte of buf){
        value = (value << 8) | byte;
        bits += 8;
        while(bits >= 5){
            bits -= 5;
            output += ALPHABET[(value >>> bits) & 31];
        }
    }
    if(bits > 0) {
        output += ALPHABET[(value << (5 - bits)) & 31];
    }
    return output;
}

// Core OTP (one-time password) implementation.
// Supports HOTP (counter-based) and TOTP (time-based).





//Default security constants
const DEFAULT_DIGITS = 6; //number of digits in OTP
const DEFAULT_ALGORITHM = 'sha256'; //default HMAC algorithm
const DEFAULT_STEP = 30; // 30-second step for TOTP
const MIN_SECRET_BYTES = 32; // 32 BYTES = 256 BITS

/**
 #PLAN 
 1 - Normalize secret input to Buffer.
 2 - Accepts either a Buffer or a base32 string

  @param {Buffer|string} secret
  @returns {Buffer}
 */

//Normalize secret input to Buffer.
function normalizeSecret(secret) {
    if (Buffer.isBuffer(secret)) return secret;
    if (typeof secret === 'string') return base32ToBuffer(secret);
    throw new Error('Secret must be a Buffer or base32 encoded string.');
}


/**
 * Generate an H O T P code string
 * @param {Buffer|string} secret - Buffer or base32 string
 * @param {number|bigint} counter - moving counter
 * @param {object} opts - { digits, algorithm }
 * @returns {string} zero-padded numeric code
 */

function hotp(secret, counter, opts = {}) {
    const digits = opts.digits || DEFAULT_DIGITS;
    const algorithm = opts.algorithm || DEFAULT_ALGORITHM;

    const key = normalizeSecret(secret);

    assertSecretStrong(key, MIN_SECRET_BYTES);

    const counterBuf = intToBuffer(counter);

    const hmac = crypto.createHmac(algorithm, key).update(counterBuf).digest();

    const offset = hmac[hmac.length - 1] & 0x0f; //dynamic truncation offset
    const codeInt = (hmac.readUInt32BE(offset) & 0x7fffffff) % 10 ** digits;

    return String(codeInt).padStart(digits, '0');
}


/**
 * Verify an HOTP code against a counter and optional look-ahead window.
 * Returns { ok: boolean, usedCounter?: bigint }.
 *
 * Note for implementers: store the usedCounter in your user storage to
 * prevent replay; only accept counters strictly greater than stored value.
 */

function hotpVerify(token, secret, counter, lookAhead = 0, opts = {}) {
    const digits = opts.digits || DEFAULT_DIGITS;
    const paddedToken = String(token).padStart(digits, '0');
    for (let i = 0; i <= lookAhead; i++) {
        const c = BigInt(counter) + BigInt(i);
        const expected = hotp(secret, c, opts);
        if(timingSafeCompare(Buffer.from(expected), Buffer.from(paddedToken))){
            return { ok: true, usedCounter: c }
        }
    }
    return { ok: false };
}


/**
 * Generate a T O T P code for the current time.
 *
 * @param {Buffer|string} secret
 * @param {object} opts - { step, digits, algorithm }
 * @returns {string}
 */

function totp(secret, opts ={}){
    const step = opts.step || DEFAULT_STEP;
    const counter = Math.floor(Date.now() / 1000 / step);
    return hotp(secret, counter, opts)
}


/**
 * Verify a T O T P token. Allows a window of steps before/after current step.
 * Returns { ok: boolean, delta?: number } where delta is the step offset.
 *
 * Implementers: for replay protection store the last accepted step value.
 */

function totpVerify(token, secret, opts={}){
    const step = opts.step || DEFAULT_STEP;
    const window = typeof opts.window === 'number' ? opts.window : 1; //allow Â±1 by default 
    const digits = opts.digits || DEFAULT_DIGITS;

    //current time step counter
    const nowCounter = Math.floor(Date.now() / 1000 / step);

    for(let i = -window; i < window; i++){
        const counter = BigInt(nowCounter + i);
        const expected = hotp(secret, counter, opts);
        if(timingSafeCompare(Buffer.from(expected), Buffer.from(String(token).padStart(digits, '0')))){
            return { ok: true, delta: 1 }
        }
    }
    return { ok: false }
}

/**
 * Convenience helper: create an "otpauth" URI string that can be turned into
 * a QR code for Google Authenticator, Authy, etc.
 *
 * Format example:
 * otpauth://totp/Issuer:account@example.com?secret=BASE32SECRET&issuer=Issuer&algorithm=SHA256&digits=6&period=30
 *
 * @param {object} params - { secretBase32, label, issuer, algorithm, digits, period }
 * @returns {string}
 */

function generateOtpauthURI(params ={}){
    if(!params.secretBase32) throw new Error('secretBase32 required');
    const label = encodeURIComponent(params.label || 'user');
    const issuer = encodeURIComponent(params.issuer || 'authentify');
    const algorithm = (params.algorithm || DEFAULT_ALGORITHM).toUpperCase();
    const digits = params.digits || DEFAULT_DIGITS;
    const period = params.period || DEFAULT_STEP;

    return `otpauth://totp/${issuer}:${label}?secret=${params.secretBase32}&issuer=${issuer}&algorithm=${algorithm}&digits=${digits}&period=${period}`;
}

exports.DEFAULT_ALGORITHM = DEFAULT_ALGORITHM;
exports.DEFAULT_DIGITS = DEFAULT_DIGITS;
exports.DEFAULT_STEP = DEFAULT_STEP;
exports.MIN_SECRET_BYTES = MIN_SECRET_BYTES;
exports.base32ToBuffer = base32ToBuffer;
exports.bufferToBase32 = bufferToBase32;
exports.generateOtpauthURI = generateOtpauthURI;
exports.generateSecret = generateSecret;
exports.hotp = hotp;
exports.hotpVerify = hotpVerify;
exports.totp = totp;
exports.totpVerify = totpVerify;
//# sourceMappingURL=index.cjs.js.map
